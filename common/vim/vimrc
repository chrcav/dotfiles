set encoding=utf-8

set nobackup
set nowritebackup
set noundofile

set number

set expandtab
set autoindent
set tabstop=2
set shiftwidth=2
set softtabstop=2
set smartindent
set smarttab

set textwidth=100
set colorcolumn=+1

set ruler
set visualbell
colorscheme ron

" easier to see characters when `set paste` is on
set listchars=tab:→\ ,eol:↲,nbsp:␣,space:·,trail:·,extends:⟩,precedes:⟨

set wrap
set linebreak

set shortmess=aoOtI    " avoid most of the 'Hit Enter ...' messages
set viminfo='20,<1000,s1000 " prevents truncated yanks, deletes, etc.

set scrolloff=999

set spell spelllang=en_us

set formatoptions-=t   " don't auto-wrap text using text width
set formatoptions+=c   " autowrap comments using textwidth with leader
set formatoptions-=r   " don't auto-insert comment leader on enter in insert

" stop complaining when switching buffers with changes
set hidden

set history=100

syntax enable
" allow sensing the filetype
filetype plugin on

" Install vim-plug if not already installed
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall
endif


if filereadable(expand("~/.vim/autoload/plug.vim"))
  call plug#begin('~/.vimplugins')

  " ------------------
  " pandoc plugins
  " ------------------
  " vim-pandoc: pandoc markdown support for vim
  Plug 'vim-pandoc/vim-pandoc'
  " vim pandoc syntax simple: adds on vim-pandoc
  Plug 'https://gitlab.com/rwxrob/vim-pandoc-syntax-simple'

  " ------------------
  " language support plugins
  " ------------------
  " vim-go: supports go fmt and checks on exit
  Plug 'fatih/vim-go'
  " vim-haskell
  Plug 'zenzike/vim-haskell'
  " rust-vim:
  Plug 'rust-lang/rust.vim'
  Plug 'racer-rust/vim-racer'
  " vim-racket
  Plug 'wlangstroth/vim-racket'

  " ------------------
  " git functionality
  " ------------------
  " gitgutter: git line status in gutter
  Plug 'airblade/vim-gitgutter'

  " ------------------
  " completion engines
  " ------------------
  " mucomplete minimalist completion
  Plug 'lifepillar/vim-mucomplete'

  " ------------------
  " syntax checking
  " ------------------
  " syntastic: uses native linters/checkers
  " Plug 'vim-syntastic/syntastic'

  " ------------------
  "  Language Server Client
  " -----------------
  Plug 'prabirshrestha/vim-lsp'

  " ------------------
  " file/folder hierarchy plugins
  " ------------------
  " nerdtree: gives access to file hierarchy
  Plug 'preservim/nerdtree'

  " ctrlp: file search and open.
  Plug 'ctrlpvim/ctrlp.vim'

  " ----------------
  " colorschemes
  " ----------------
  Plug 'tek256/simple-dark'

  call plug#end()

  " golang plugin configurations
  if exists('g:plugs["vim-go"]')
    let g:go_fmt_command = 'goimports' " autoupdate import
    let g:go_fmt_autosave = 1
  else
    autocmd vimleavepre *.go !gofmt -w %
  endif

  " mucomplete settings
  if exists('g:plugs["vim-mucomplete"]')
    set completeopt+=menuone
    "let g:mucomplete#enable_auto_at_startup = 1
  endif

  " rust racer settings
  " requires: racer
  " $ rustup toolchain add nightly
  " $ cargo +nightly install racer
  if exists('g:plugs["vim-racer"]')
    let g:racer_experimental_completer = 1
    augroup Racer
      autocmd!
      autocmd FileType rust nmap <buffer> gd         <Plug>(rust-def)
      autocmd FileType rust nmap <buffer> gs         <Plug>(rust-def-split)
      autocmd FileType rust nmap <buffer> gx         <Plug>(rust-def-vertical)
      autocmd FileType rust nmap <buffer> gt         <Plug>(rust-def-tab)
      autocmd FileType rust nmap <buffer> <leader>gd <Plug>(rust-doc)
    augroup END
  endif

  " syntastic plugin configurations
  if exists('g:plugs["syntastic"]')
    set statusline+=%#warningmsg#
    set statusline+=%{SyntasticStatuslineFlag()}
    set statusline+=%*
    let g:syntastic_always_populate_loc_list = 1
    let g:syntastic_cpp_include_dirs = ['extern/glfw/include']
    let g:syntastic_c_include_dirs = ['extern/glfw/include', 'extern/stb']
    let g:syntastic_c_check_header = 1
    let g:syntastic_cpp_check_header = 1
    let g:syntastic_auto_loc_list = 1
    let g:syntastic_check_on_open = 1
    let g:syntastic_check_on_wq = 0
  endif

  " vim-lsp plugin configuration
  if exists('g:plugs["vim-lsp"]')
    function! s:on_lsp_buffer_enabled() abort
      setlocal omnifunc=lsp#complete
      setlocal signcolumn=yes
      if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
      nmap <buffer> gd <plug>(lsp-definition)
      nmap <buffer> gs <plug>(lsp-document-symbol-search)
      nmap <buffer> gS <plug>(lsp-workspace-symbol-search)
      nmap <buffer> gr <plug>(lsp-references)
      nmap <buffer> gi <plug>(lsp-implementation)
      nmap <buffer> gt <plug>(lsp-type-definition)
      nmap <buffer> <leader>rn <plug>(lsp-rename)
      nmap <buffer> [g <plug>(lsp-previous-diagnostic)
      nmap <buffer> ]g <plug>(lsp-next-diagnostic)
      nmap <buffer> K <plug>(lsp-hover)
      nnoremap <buffer> [] :LspDocumentDiagnostic<CR>
      nnoremap <buffer> <expr><c-f> lsp#scroll(+4)
      nnoremap <buffer> <expr><c-d> lsp#scroll(-4)

      let g:lsp_format_sync_timeout = 1000
      autocmd! BufWritePre *.rs,*.go call execute('LspDocumentFormatSync')

      let g:lsp_diagnostics_echo_cursor = 1
      " refer to doc to add more commands
    endfunction

    augroup lsp_install
      au!
      " call s:on_lsp_buffer_enabled only for languages that has the server registered.
      autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
    augroup END

    if executable('clangd')
      augroup lsp_clangd
        autocmd!
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'clangd',
                    \ 'cmd': {server_info->['clangd', '-background-index']},
                    \ 'whitelist': ['c', 'cpp', 'objc', 'objcpp'],
                    \ })
        autocmd FileType c setlocal omnifunc=lsp#complete
        autocmd FileType cpp setlocal omnifunc=lsp#complete
        autocmd FileType objc setlocal omnifunc=lsp#complete
        autocmd FileType objcpp setlocal omnifunc=lsp#complete
      augroup end
    endif
  endif

  if exists('g:plugs["simple-dark"]')
    colorscheme simple-dark
  endif
endif

" highlight trailing whitespace
highlight link ExtraWhitespace Error
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

" rust format call on leave.
autocmd vimleavepre *.rs !rustfmt %

"function! TrimWhiteSpace()
"    %s/\s\+$//e
"endfunction
"autocmd BufWritePre *.h,*.c :call TrimWhiteSpace()

set omnifunc=syntaxcomplete#Complete " enable omni-completion
" requires gopls
" $ go get golang.org/x/tools/gopls
autocmd FileType go setlocal omnifunc=go#complete#Complete

" tells vim to remember the current line on close and reload.
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

" filetype for crux ports
au BufNewFile,BufRead *Pkgfile set filetype=sh

set pastetoggle=<F3>

" disable arrow keys.
noremap <up> :echoerr "Umm, use k instead"<CR>
noremap <down> :echoerr "Umm, use j instead"<CR>
noremap <left> :echoerr "Umm, use h instead"<CR>
noremap <right> :echoerr "Umm, use l instead"<CR>
inoremap <up> <NOP>
inoremap <down> <NOP>
inoremap <left> <NOP>
inoremap <right> <NOP>

map <C-n> :NERDTreeToggle<CR>

